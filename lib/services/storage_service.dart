// lib/services/storage_service.dart
import 'package:hive_flutter/hive_flutter.dart';
import '../models/user_model.dart';
import '../models/session_model.dart';
import '../models/achievement_model.dart';
import '../models/island_model.dart';

class StorageService {
  static const String _userBoxName = 'user_box';
  static const String _sessionsBoxName = 'sessions_box';
  static const String _achievementsBoxName = 'achievements_box';
  static const String _islandBoxName = 'island_box';
  static const String _settingsBoxName = 'settings_box';

  late Box<UserModel> _userBox;
  late Box<SessionModel> _sessionsBox;
  late Box<AchievementModel> _achievementsBox;
  late Box<IslandModel> _islandBox;
  late Box<dynamic> _settingsBox;

  static StorageService? _instance;
  static StorageService get instance => _instance ??= StorageService._();

  StorageService._();

  /// Initialize Hive and open all boxes
  Future<void> initialize() async {
    await Hive.initFlutter();

    // Register Hive adapters
    _registerAdapters();

    // Open boxes
    _userBox = await Hive.openBox<UserModel>(_userBoxName);
    _sessionsBox = await Hive.openBox<SessionModel>(_sessionsBoxName);
    _achievementsBox = await Hive.openBox<AchievementModel>(_achievementsBoxName);
    _islandBox = await Hive.openBox<IslandModel>(_islandBoxName);
    _settingsBox = await Hive.openBox<dynamic>(_settingsBoxName);
  }

  void _registerAdapters() {
    // Register all model adapters
    // Note: These will be generated by build_runner
    if (!Hive.isAdapterRegistered(0)) {
      Hive.registerAdapter(UserModelAdapter());
    }
    if (!Hive.isAdapterRegistered(1)) {
      Hive.registerAdapter(SessionModelAdapter());
    }
    if (!Hive.isAdapterRegistered(2)) {
      Hive.registerAdapter(AchievementModelAdapter());
    }
    if (!Hive.isAdapterRegistered(3)) {
      Hive.registerAdapter(IslandModelAdapter());
    }
    if (!Hive.isAdapterRegistered(4)) {
      Hive.registerAdapter(SessionTypeAdapter());
    }
    if (!Hive.isAdapterRegistered(5)) {
      Hive.registerAdapter(AchievementRarityAdapter());
    }
    if (!Hive.isAdapterRegistered(6)) {
      Hive.registerAdapter(IslandThemeAdapter());
    }
    if (!Hive.isAdapterRegistered(7)) {
      Hive.registerAdapter(BuildingTypeAdapter());
    }
    if (!Hive.isAdapterRegistered(8)) {
      Hive.registerAdapter(BuildingAdapter());
    }
    if (!Hive.isAdapterRegistered(9)) {
      Hive.registerAdapter(DecorationAdapter());
    }
  }

  // User data operations
  Future<UserModel?> getUser() async {
    return _userBox.get('current_user');
  }

  Future<void> saveUser(UserModel user) async {
    await _userBox.put('current_user', user);
  }

  Future<void> deleteUser() async {
    await _userBox.delete('current_user');
  }

  // Session data operations
  Future<void> saveSession(SessionModel session) async {
    await _sessionsBox.put(session.id, session);
  }

  Future<SessionModel?> getSession(String id) async {
    return _sessionsBox.get(id);
  }

  Future<List<SessionModel>> getAllSessions() async {
    return _sessionsBox.values.toList();
  }

  Future<List<SessionModel>> getSessionsForDate(DateTime date) async {
    final allSessions = await getAllSessions();
    return allSessions.where((session) {
      return session.startTime.day == date.day &&
             session.startTime.month == date.month &&
             session.startTime.year == date.year;
    }).toList();
  }

  Future<List<SessionModel>> getSessionsForDateRange(DateTime start, DateTime end) async {
    final allSessions = await getAllSessions();
    return allSessions.where((session) {
      return session.startTime.isAfter(start) && session.startTime.isBefore(end);
    }).toList();
  }

  Future<void> deleteSession(String id) async {
    await _sessionsBox.delete(id);
  }

  Future<void> clearAllSessions() async {
    await _sessionsBox.clear();
  }

  // Achievement data operations
  Future<void> saveAchievements(List<AchievementModel> achievements) async {
    await _achievementsBox.clear();
    for (final achievement in achievements) {
      await _achievementsBox.put(achievement.id, achievement);
    }
  }

  Future<List<AchievementModel>> getAchievements() async {
    return _achievementsBox.values.toList();
  }

  Future<void> unlockAchievement(AchievementModel achievement) async {
    await _achievementsBox.put(achievement.id, achievement);
  }

  Future<bool> isAchievementUnlocked(String achievementId) async {
    return _achievementsBox.containsKey(achievementId);
  }

  Future<void> clearAchievements() async {
    await _achievementsBox.clear();
  }

  // Island data operations
  Future<void> saveIsland(IslandModel island) async {
    await _islandBox.put('user_island', island);
  }

  Future<IslandModel?> getIsland() async {
    return _islandBox.get('user_island');
  }

  Future<void> saveFriendIslands(List<IslandModel> islands) async {
    await _islandBox.clear();
    await _islandBox.put('user_island', islands.first); // Keep user island

    for (int i = 0; i < islands.length - 1; i++) {
      await _islandBox.put('friend_island_\$i', islands[i + 1]);
    }
  }

  Future<List<IslandModel>> getFriendIslands() async {
    final islands = <IslandModel>[];
    for (final key in _islandBox.keys) {
      if (key.toString().startsWith('friend_island_')) {
        final island = _islandBox.get(key);
        if (island != null) islands.add(island);
      }
    }
    return islands;
  }

  Future<void> deleteIsland() async {
    await _islandBox.delete('user_island');
  }

  // Settings operations
  Future<void> saveSetting(String key, dynamic value) async {
    await _settingsBox.put(key, value);
  }

  Future<T?> getSetting<T>(String key) async {
    return _settingsBox.get(key) as T?;
  }

  Future<void> deleteSetting(String key) async {
    await _settingsBox.delete(key);
  }

  Future<void> clearSettings() async {
    await _settingsBox.clear();
  }

  // App settings helpers
  Future<bool> isDarkModeEnabled() async {
    return await getSetting<bool>('dark_mode') ?? false;
  }

  Future<void> setDarkMode(bool enabled) async {
    await saveSetting('dark_mode', enabled);
  }

  Future<bool> areNotificationsEnabled() async {
    return await getSetting<bool>('notifications') ?? true;
  }

  Future<void> setNotifications(bool enabled) async {
    await saveSetting('notifications', enabled);
  }

  Future<bool> isSoundEnabled() async {
    return await getSetting<bool>('sound') ?? true;
  }

  Future<void> setSound(bool enabled) async {
    await saveSetting('sound', enabled);
  }

  Future<String> getSelectedTheme() async {
    return await getSetting<String>('theme') ?? 'arctic';
  }

  Future<void> setSelectedTheme(String theme) async {
    await saveSetting('theme', theme);
  }

  // Statistics and analytics
  Future<Map<String, dynamic>> getStatistics() async {
    final sessions = await getAllSessions();
    final completedSessions = sessions.where((s) => s.wasCompleted).toList();

    final totalFocusTime = completedSessions.fold<int>(
      0, 
      (sum, session) => sum + session.actualDuration.inMinutes,
    );

    final totalSessions = completedSessions.length;
    final averageSessionLength = totalSessions > 0 
        ? totalFocusTime / totalSessions 
        : 0.0;

    final sessionsThisWeek = completedSessions.where((session) {
      final now = DateTime.now();
      final weekStart = now.subtract(Duration(days: now.weekday - 1));
      return session.startTime.isAfter(weekStart);
    }).length;

    final sessionsThisMonth = completedSessions.where((session) {
      final now = DateTime.now();
      final monthStart = DateTime(now.year, now.month, 1);
      return session.startTime.isAfter(monthStart);
    }).length;

    return {
      'totalFocusTime': totalFocusTime,
      'totalSessions': totalSessions,
      'averageSessionLength': averageSessionLength,
      'sessionsThisWeek': sessionsThisWeek,
      'sessionsThisMonth': sessionsThisMonth,
      'completionRate': sessions.isNotEmpty 
          ? (completedSessions.length / sessions.length) * 100 
          : 0.0,
    };
  }

  // Data export/import
  Future<Map<String, dynamic>> exportData() async {
    final user = await getUser();
    final sessions = await getAllSessions();
    final achievements = await getAchievements();
    final island = await getIsland();

    return {
      'user': user?.toJson(),
      'sessions': sessions.map((s) => s.toJson()).toList(),
      'achievements': achievements.map((a) => a.toJson()).toList(),
      'island': island?.toJson(),
      'exportDate': DateTime.now().toIso8601String(),
      'version': '1.0.0',
    };
  }

  Future<void> importData(Map<String, dynamic> data) async {
    // Clear existing data
    await _userBox.clear();
    await _sessionsBox.clear();
    await _achievementsBox.clear();
    await _islandBox.clear();

    // Import user data
    if (data['user'] != null) {
      final user = UserModel.fromJson(data['user']);
      await saveUser(user);
    }

    // Import sessions
    if (data['sessions'] != null) {
      for (final sessionData in data['sessions']) {
        final session = SessionModel.fromJson(sessionData);
        await saveSession(session);
      }
    }

    // Import achievements
    if (data['achievements'] != null) {
      final achievements = (data['achievements'] as List)
          .map((a) => AchievementModel.fromJson(a))
          .toList();
      await saveAchievements(achievements);
    }

    // Import island
    if (data['island'] != null) {
      final island = IslandModel.fromJson(data['island']);
      await saveIsland(island);
    }
  }

  // Cleanup and maintenance
  Future<void> clearAllData() async {
    await _userBox.clear();
    await _sessionsBox.clear();
    await _achievementsBox.clear();
    await _islandBox.clear();
    await _settingsBox.clear();
  }

  Future<void> optimizeStorage() async {
    // Remove sessions older than 1 year
    final oneYearAgo = DateTime.now().subtract(const Duration(days: 365));
    final allSessions = await getAllSessions();

    for (final session in allSessions) {
      if (session.startTime.isBefore(oneYearAgo)) {
        await deleteSession(session.id);
      }
    }

    // Compact boxes
    await _userBox.compact();
    await _sessionsBox.compact();
    await _achievementsBox.compact();
    await _islandBox.compact();
    await _settingsBox.compact();
  }

  // Close all boxes (for app termination)
  Future<void> close() async {
    await _userBox.close();
    await _sessionsBox.close();
    await _achievementsBox.close();
    await _islandBox.close();
    await _settingsBox.close();
  }
}
